//#include "pch.h"
//
////2.  Пользователь вводит строку вида 2234 + 455 - 23 + 1234 ...
////Программа подсчитывает результат.Операторы: +-Оформить в виде функции int calc(char* s)
//
//
////int calc(char* s)
////{
////    
////    char str[20];
////    cout << "Insert the expression: " << endl;
////    cin.getline(str, 19);
////    int second_number, n, i;
////    float result, first_number;
////    while (true) 
////    {
////        
////        n = strlen(str);
////        result = 0, first_number = 0;
////        second_number = 1, n, i = 0;
////
////        while (i < n)//цикл только один раз через массив 
////        {
////            while (str[i] >= '0' && str[i] <= '9')//Число
////            {
////                first_number = first_number * 10 + (str[i] - '0');
////                i++;
////            }
////            switch (str[i])
////            {
////            case '+': {
////                result += first_number * second_number;
////                first_number = 0;
////                break;
////            }
////            case '-': {
////                result += first_number * second_number;
////                first_number = 0;
////                second_number = -1;
////                break;
////            }
////            default:
////                if (str[i] != (str[i] >= '0' && str[i] <= '9'))
////                {
////                    cout << "Error! Wrong input." << endl;
////                    break;
////                }
////            }
////            if (i >= (n - 1))
////            {
////                result += first_number * second_number;
////            }
////            i++;
////        }
////    }
////}
////
////int main()
////{
////    char str[20];
////    int result;
////
////    result = calc(str);
////        //cout << "=" << calc(str) << endl;
////        system("pause");
////        system("cls");
////    
////}
//
////void AnyLine(char symb, int count)
////{
////	for (int i = 0; i < count; i++)
////	{
////		cout << symb;
////		cout << "\n";
////	}
////}
////int main()
////{
////	AnyLine('+', 5);
////	AnyLine('-', 5);
////
////}
//
////int MyPow(int Digit, int Pow)
////{
////	int key = 2;
////	for (int i = 0; i < Pow; i++)
////	{
////		key *= Digit+Pow;
////		return key;
////	}
////}
////
////int main()
////{
////	int res = MyPow(5, 5);
////	cout << "Res = " << res << endl;
////	return 0;
////}
//
////int Max(int a, int b)
////{
////	return a > b ? a : b;
////}
////
////int main()
////{
////	int result = Max(10, 30);
////	cout << "Max is: " << result << endl;
////
////	cout << "Max is: " << Max(42, 2);
////	return 0;
////}
//
////int Min(int a, int b)
////{
////	return a < b ? a : b;
////}
////int Max(int a, int b)
////{
////	return a > b ? a : b;
////}
////
////int main()
////{
////	int result = Max(10, 30);
////	cout << "Max = " << result << endl;
////
////	cout << "Min = " << Min(10, 30);
////	return 0;
////}
//
////void Second()
////{
////	cout << "\nSecond function\n";
////}
////void First()
////{
////	cout << "\nBegin first function\n";
////	Second();
////	cout << "\nEnd first function\n";
////}
////
////int main()
////{
////	First();
////	return 0;
////}
//
//
////void Change(int One, int Two)
////{
////	cout << One << " " << Two << "\n\n";
////	int temp = One;
////	One = Two;
////	Two = temp;
////	cout << One << " " << Two << "\n\n";
////}
////
////int main()
////{
////	int a = 1, b = 2;
////	cout << a << " " << b << "\n\n";
////	Change(a, b);
////	cout << a << " " << b << "\n\n";
////	return 0;
////}
//
//
////void ShowArray(int array[], int size)
////{
////	for (int i = 0; i < size; i++)
////	{
////		cout << array[i] << " ";
////		
////	}
////	cout << endl;
////}
////
////void InitArray(int arr[], int size)
////{
////	for (int i = 0; i < size; i++)
////	{
////		arr[i] = rand() % 100;
////	}
////	cout << endl;
////}
////
////int main()
////{
////	srand(time(NULL));
////	const int aSize = 10;
////	int iArr[aSize];
////	InitArray(iArr, aSize);
////	ShowArray(iArr, aSize);
////	return 0;
////}
//
//
//
////void ShowMatrix(int matr[][3], int rows, int cols)
////{
////	for (int i = 0; i < rows; i++)
////	{
////		for (int j = 0; j < cols; j++)
////		{
////			cout << matr[i][j] << " ";
////		}
////		cout << endl;
////	}
////	cout << endl;
////}
////
////void InitMatrix(int matr[][3], int rows, int cols)
////{
////	for (int i = 0; i < rows; i++)
////	{
////		for (int j = 0; j < cols; j++)
////		{
////			matr[i][j] = rand() % 10;
////		}
////	}
////	cout << endl;
////}
////
////int main()
////{
////	srand(time(NULL));
////	const int mRows = 3;
////	const int mCols = 3;
////	int iMatr[mRows][mCols];
////	InitMatrix(iMatr, mRows, mCols);
////	ShowMatrix(iMatr, mRows, mCols);
////	return 0;
////}
//
//
////void foot(int i, int j = 7); // допустимо
////void foot(int i, int j = 2, int k); // недопустимо
////void foot(int i, int j = 3, int k = 7); // допустимо
////// допустимо
////void foot(int i = 1, int j = 2, int k = 3);
////void foot(int i = -3, int j); // недопустимо
//
////int main()
////{
////	cout << "Please, insert the expression (+ or -): ";
////	int lval = 0;
////	int rval;
////	char op;
////	int res;
////	cin >> lval >> op >> rval; // Считываем что - то вроде 1+3
////
////	if (op == '+')
////		res = lval + rval; // сложение
////	else if (op == '-')
////		res = lval - rval; //вычитание
////	cout << "Result = " << res << endl;
////	
////}
//
//
////int main()
////{
////	cout << "Please, insert the expression (+ , - , * /):" << endl;
////	int lval = 0;
////	int rval;
////	char op;
////	cin >> lval; // считываем самый левый операнд
////
////	if (!cin) cout << "Error";
////	while (cin >> op) { // считываем оператор и правый операнд в цикле.
////		cin >> rval;
////		if (!cin)cout << "Error";
////		switch (op) 
////		{
////			case '+':
////				lval += rval; // сложение: lval = lval + rval
////				break;
////			case '-':
////				lval -= rval; // вычитание.
////				break;
////			case '*':
////				lval *= rval; // умножение
////				break;
////			case '/':
////				lval /= rval; // деление
////				break;
////
////			default: // нет другого оператора: выводим результат
////				cout << "Result = " << lval << '\n';
////				return 0;
////		}
////		
////	}
////	
////}
//
////самый полезный ответ на эти вопросы таков : разложите выражение
////на лексемы, т.е.сначала считайте символы, а затем объедините их в лексемы
////(tokens).
//
////Анализируя примеры выражений на языке С++,
////можно выделить три вида лексем
//
////1) Литералы с плавающей точкой, определенные в языке C++, например 3.14,
////   0.274e2 и 42.
////2) Операторы, например + , –, *, / , % .
////3) Скобки(, )
//
////Общепринятое
////решение этой задачи — хранить каждую лексему в виде пары(вид, значение).
////Вид идентифицирует лексему как число, оператор или скобку
//
////Как должна выглядеть лексема в нашей программе ? Иначе говоря, как должен
////выглядеть тип Token ? Класс Token должен предусматривать выполнение операто -
////ров, например + и –, а
//
////Класс Token — это тип(такой же, как int или char), поэтому его можно ис -
////пользовать для определения переменных и хранения значений.Он состоит из двух
////частей(членов) : kind и value.Ключевое слово class означает “тип, определенный
////пользователем”; это значит, что он содержит члены(хотя в принципе может их и не
////	содержать).
//
//// Примеры:
//
////Token t; // t — объект класса Token
////t.kind = '+'; // t представляет операцию +
////Token t2; // t2 — другой объект класса Token
////t2.kind = '8'; // цифра 8 означает, что "вид" является числом
////t2.value = 3.14;
//
////Для доступа к члену класса используется обозначение 
////имя_объекта.имя_члена Выражение t.kind читается как “член kind объекта t”
//
////Объекты класса Token можно копиро -
////вать так же, как и переменные типа int
////
////Token tt = t; // копирование при инициализации
////if (tt.kind != t.kind) error("невозможно!");
////t = t2; // присваивание
////cout << t.value; // вывод числа 3.14
//
////class Token 
////{
////public: // публичный
////	char kind; // вид лексемы
////	double value; // для чисел: значение.
////	Token(char ch) // создаёт функцию класса Token из char.
////		:kind(ch), value(0){}
////
//////фрагмент:kind(ch), value(0) означает “инициали -
//////зировать член kind значением переменной ch и установить член value равным нулю
////
////	Token(char ch, double val)  // создаёт объект класса Token
////		:kind(ch), value(val){} // из переменных типа
////	                            // char и double
//////фрагмент:kind(ch), value(val) означает
//////“инициализировать член kind значением переменной ch и установить член value
//////равным переменной val”.
////// 
//////Token t2('8', 11.5); // инициализируем t2,
////// так что t2.kind = '8' и t2.value = 11.5
////
////
////};
//
////Можно считать входную информацию в вектор объектов Token
//
////class Token 
////{
////public:
////	char kind; // вид лексемы
////	double value; // для чисел: значение
////};
////
////Token get_token(); // считывает объекты класса Token из потока cin
////vector<Token> tok; // Здесь храним объекты класса Token
//
////int main()
////{
////	while (cin)
////	{
////		Token t = get_token();
////		tok.push_back(t); //Функция push_back () — это один из способов вставить новый элемент в конец вектора, который увеличивает размер вектора на 1.
////	}
////
////	for (int i = 0; i < tok.size(); i++)
////	{
////		if (tok[i].kind == '*') { // нашли умножение
////			double d = tok[i - 1].value * tok[i + 1].value; // умножает числа который были операндами *
////		}
////	}
////}
////Теперь можно сначала считать выражение, а вычислить его позднее.Например,
////Эти лексемы можно использовать для поиска операции умножения и ее операн -
////дов.
//
////Существует стандартный способ придать выражениям смысл : сначала ввести
////символы, а затем собрать их в лексемы(как мы и сделали).Поэтому, если мы вве -
////дем выражение
////45 + 11.5 / 7
////программа должна создать список лексем
////45
////+
////11.5
//// /
////7
////Лексема — это последовательность символов, представляющих собой отдель -
////ную единицу языка, например число или оператор.
//
////1. 45 — это Выражение, за которым следует символ + , поэтому следует искать
////Терм, чтобы применить правило Выражение + Терм.
////2. 11.5 — это Терм, за которым следует символ*, поэтому следует искать Первич -
////ное выражение, чтобы применить правило Терм* Первичное выражение.
////3. 7 — это первичное выражение, поэтому 11.5 * 7 — это Терм в соответствии
////с правилом Терм * Первичное выражение.Теперь можем убедиться, что
////45 + 11.5 * 7 — это Выражение в соответствии с правилом Выражение + Терм.
////В частности, это Выражение, которое сначала выполняет умножение 11.5 * 7,
////а затем сложение 45 + 11.5 * 7 так, будто мы написали выражение 45 + (11.5 * 7).
//
////Считывание потока лексем в соответствии с грамматикой называется синтаксиче -
////ским разбором(parsing), а программа, выполняющая эту работу, называется син -
////таксическим анализатором(parser, или syntax analyser).
//
////Напишем Программу, реализующую грамматику, часто называют программой грамматического
////разбора(parser). Используя класс Token
//
////Для реализации калькулятора нам нужны четыре функции : 
////одна — для считывания лексем и по одной для каждого грамматического правила.
////
////get_token() // считывает символы и составляет лексемы
////// использует поток cin
////expression() // реализует операции + и –
////// вызывает функции term() и get_token()
////term() // реализует операции *, / и %
////// вызывает функции primary() и get_token()
////primary() // реализует числа и скобки
////// вызывает функции expression() и get_token()
//
////Функция get_token() стоит особняком : поскольку она обрабатывает лексемы,
////а не выражения, она не может возвращать значения подвыражений.Например, +
////и(— это не выражения.Таким образом, функция get_token() должна возвращать
////	объект класса Token.
//
//// функции, подчиняющиеся грамматическим правилам
////Token get_token() // считывает символы и составляет лексемы
////double expression() // реализует операции + и –
////double term() // реализует операции *, / и %
////double primary() // реализует числа и скобки
//
////class Token_stream {
////public:
////	// пользовательский интерфейс
////private:
////	// детали реализации
////	// (скрывается от пользователей класса Token_stream)
////};
//
//double term();
//double primary();
//class Token
//{
//public:
//	char kind; // вид лексемы
//	double value; // для чисел: значение
//	vector<Token> tok; // Здесь храним объекты класса Token
//};
//
//class Token_stream {
//public:
//	Token_stream(); // Создаёт объект класса Token_stream
//					// считывающий данные из потока cin
//	Token get();    // получает объект класса Token
//	void putback(Token t); // Возвращает объект класса Token обратно
//private:
//	// детали реализации
//	bool full; // находится ли в буфере объект класса Токен?
//	Token buffer; // здесь хранится объект класса Токен
//	              // возвращаемый в поток функцией putback()
//}; 
//
//Token_stream ts; // об. класса с именем ts
//Token t = ts.get(); // получаем след об. Token из ts.
//ts.putback(t); // возвращает t класса Token обратно в ts.
//
//Token_stream::Token_stream()
//	:full(false), buffer(0) // в буфере нет ни одного объекта
//	// класса Token
//{
//}
//
////Token get_token(); // считывает объекты класса Token из потока cin
//
//
//
//double expression()
//{
//	double left = term(); // считываем и вычисляем Терм
//	Token t = ts.get(); // получаем следующую лексему
//	while (true) {
//		switch (t.kind) {
//		case '+':
//			left += term(); // вычисляем Терм и добавляем его
//			t = ts.get();
//			break;
//		case '–':
//			left -= term(); // вычисляем Терм и вычитаем его
//			t = ts.get();
//			break;
//		default:
//			return left; // финал: символов + и – нет;
//			// возвращаем ответ
//		}
//	}
//}
//
//double term()
//{
//	double left = primary();
//	Token t = ts.get();
//	while (true) {
//		switch (t.kind) {
//		case '*':
//			left *= primary();
//			t = ts.get();
//			break;
//		case '/':
//		{ double d = primary(); // Если мы хотим определить и инициализировать переменные в опера-
//		                        //торе switch, то должны поместить ее в блоке
//		if (d == 0) cout << "Error!Cannot be divided by 0!";
//		left /= d;
//		t = ts.get();
//		break;
//		}
//		default:
//			return left;
//		}
//	}
//}
//
//double primary()
//{
//	Token t = ts.get();
//	switch (t.kind) {
//	case '(': // обработка варианта '(' выражение ')'
//	{ double d = expression();
//	t = ts.get();
//	if (t.kind != ')') cout<<"')' expected";
//	return d;
//	}
//	case '8': // используем '8' для представления числа
//		return t.value; // возвращаем значение числа
//	default:
//		cout << "Error! Waiting first expression.";
//	}
//	return 0;
//}
////Ключевое слово catch используется для определения блока кода (так называемого «блока catch»), 
////который обрабатывает исключения определенного типа данных. 
////Блоки try и catch работают вместе. Блок try обнаруживает любые исключения, которые были выброшены в нем, 
////и направляет их в соответствующий блок catch для обработки.
//int main()
//try {
//	while (cin)
//		cout << expression() << '\n';
//}
//catch (exception& e) {
//	cerr << e.what() << endl; //Cerr – обработка ошибок в C++
//	return 1;
//}
//catch (...) {
//	cerr << "exception \n";
//	return 2;
//}