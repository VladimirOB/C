#include "pch.h"

int main()
{
char str[400];
cin.getline(str, 399);

for (int i = 0; i < str[i] != 0; i++)
{
    for (int j = i + 1; j < str[j] != 0; j++)
    {
        if (str[i] == str[j])
            str[j] = ' ';
    }
}
cout << "OTBET" << endl;
cout << str;

return 0;
}



//char* removeDuplicate(char str[], int n)
//{
//    // Используется как индекс в измененной строке 
//    int cnt = 0;
//    // Пройтись по всем 
//    for (int i = 0; i < n; i++) 
//    {
//        int j;
//
//        for (j = 0; j < i; j++)
//            if (str[i] == str[j])
//                break;
//        if (j == i)
//            str[cnt++] = str[i];
//    }
//    return str;
//}
//int main()
//{
//    char str[400];
//    cin.getline(str, 399);
//    int n = sizeof(str) / sizeof(str[0]);
//    cout << removeDuplicate(str, n);
//    return 0;
//}

//Я думаю, что std::unique будет работать, даже если ваша строка не отсортирована, потому что все, что она удаляет, -это последовательные дубликаты.
//
//Конечно, он не будет знать, что / здесь является специальным символом, и вы можете обнаружить, что имена файлов, 
//содержащие двойные буквы, также неожиданно изменяются на одинарные буквы, возможно, досадно.
//
//Это тоже O(N), но этого нельзя избежать.
//
//Один алгоритм, который будет хорошо работать, -это std::remove_if, потому что вы можете добавить свой собственный «функтор», 
//который может сохранять состояние, чтобы он знал, какой был последний символ.

